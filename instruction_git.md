# **Инструкция по работе с системой контроля версий Git**

![Эмблема Git](git.jpg)

Git (произносится «гит») — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.

## Инициализация репозитория

Чтобы создать (инициализировать) новый репозиторий нужно в терминале ввести команду:

    git init

Репозиторий будет создан в той папке, из которой вызывалась команда

## Проверка состояния репозитория

Чтобы проверить текущее состояние репозитория нужно ввести в терминале команду:

    git status

## Добавление изменения к отслеживанию версионности

Чтобы добавить сделанное изменение к отслеживанию (поместить в индекс) нужно ввести команду:

    git add <имя файла>

где вместо <имя файла> вводится путь к файлу относительно расположения репозитория.

## Фиксация изменений

Чтобы зафиксировать изменение используется команда:

    git commit

В таком случае откроется окно для ввоба краткого описания сделанных изменений.

Чтобы сделать это одновременно с фиксацией используется команда:

    git commit -m "комментарий"

## Просмотр истории изменений

Чтобы посмотреть историю изменений используется комада

    git log

Для просмотра изменений с выводом одного коммита в одну строку используется команда

    git log --oneline

Для просмотра всех имеющихся коммитов используется команда

    git log --all

Для просмотра лога с графическим изображением веток используется команда

    git log --graph

Все указанные флаги могут использоваться вместе:

    git log --all --oneline --graph

## Просмотр различий между изменениями

Для просмотра отличий между текущим состоянием репозитория и последним сохраненным изменением используется команда

    git diff

Можно также посмотреть разницу между любыми двуми коммитами. Для этого используется команда

    git diff <хэш1> <хэш2>

## Переключение на нужное изменение

Чтобы переключиться на нужный коммит используется команда

    git checkout <хэш>

## Ветки в Git

### Создание новой ветки

Чтобы создать новую ветку используется команда

    git branch <имя_ветки>

### Просмотр всех веток

Чтобы посмотреть какие ветки существуют и на какой мы находимся используется команда

    git branch

### Переключение между ветками

Чтобы переключиться на другую ветку используется команда

    git checkout <имя_ветки>

### Слияние веток

Чтобы влить одну ветку в другую необходимо находясь в целевой ветке (КУДА будем делать слияние) выполнить команду

    git merge <имя_вливаемой_ветки>

### Конфликты при слиянии

Если одна и та же строка в разный версиях записана по разному возникнет конфликт.
Чистый гит автоматически сохраняет оба изменения, далее требуется вручную внести нужные правки и сделать коммит.

VSСode дает возможность выбрать какое изменение сохранить (входящее, существующее или оба).

### Удаление ветки

Чтобы удалить ветку, которая больше не нужно (например после слияния) используется команда

    git branch -d <имя_ветки>


__________________________________________________________

# Инструкция по работе с Git &  Инструкция по написанию текстов в MrakDown

Тут будет общая информация про git

## Выделение текстов

В MarkDown есть несколько различных способов выделить текст. 

Например, Вы можете обрамить слово (или кусок текста) звездочками (*) или нижним подчеркиванием (_) и тогда он будет написан курсивом - *вот так* или _вот так_.

Также вы можете выделить текст полужирным шрифтом, для этого необходимо обрамить текст двойными звездочками (**) или двойными подчеркиванием (__) - **полужирный текст** или __полужирный текст__.

Мы можем комбинировать разные способы выделения полужирным и курсивом. Например, вот так - _Курсивный и одновременно **полужирный текст**_.

## Работа со списками

Списки выбают нумерованными и ненумерованными. Если нам нужен нумерованный список, то мы просто пишем каждый элемент со своим номером на новой строке, а MarkDown сам его красиво оформит. Например, вот так:

1. первый элемент
2. второй элемент
3. третий элемент

Если нам нужны ненумерованные списки, то мы вместо числа (номера элемента) можем поставить +. Например, вот так:

+ Элемент
+ Элемент

## Картинки в тексте

Чтобы добавить картинку в текст необходимо использовать следующий синтаксис - ставим восклицательный знак, потом в квадратных скобках указываем текст, а в круглых - адрес файла с картинкой. Адрес относительный или абсолютный. Например, вот так:

![Эмблема картинки](Seminar1.jpg)


## Исключение отслеживания файлов

Если мы хотим чтобы в нашем репозитории были картинки, но они не отслеживались нужно создать файл **.gitignore**

    .gitignore

Далее в файле .gitignore прописываем символ *.jpg (общий тип расширения картинки) либо индивидуально через название конкретного файла, к примеру Seminar1.jpg

    *.jpg


## Ссылки в текста

Ссылка на [GitHub](https://github.com/)


## Создание нового репозитория

Для создания нового репозитория (инициализации) нужно ввести команду 

    git init

## Проверка состояния репозитория

Чтобы проверить текущее состояние репозитория нужно ввести команду:

    git status


Команда **git inint** 

    git init

_Инициализация репозитория_

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.


Команда **git status** 

    git status

_Проверка статуса репозитория_

Просмотреть статус нужного репозитория можно по ключевому слову status: его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.


Команда **git add**

    git add

    Пример:
    $ git add hello.txt

_Добавление отдельных файлов или всех файлов в область подготовленных файлов_

В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой add
    
  
Команда **git commit**

    git commit

_Внесение сообщений об изменении через редактор сообщений/комментариев_


Команда **git commit -m "message"**

    git commit -m "message"

_Внесение сообщений об изменении однострочным сообщением_

Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»
Буквально git commit -m используется для отправки файлов в промежуточной области


Команда **git commit -a**

    git commit -a

_Добавит все файлы и создаст коммит_

Git commit с флагом -a — совершит коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено.


Команда **git commit -am**

    git commit -am

_Используется для отправки файлов, которые были отслежены_

Если вы используете git commit -am, вы можете пропустить шаг git add a.txt, потому что git commit -am может отправлять отслеживаемые файлы, а a.txt уже был отслежен в начале
Т.е. вместе с коммитом мы добавляем и фиксируем все изменения. 
Пример: git commit -am "текст_сообщения".


Команда **git log**

    git log

_Просмотр истории коммитов с изменениями_

По умолчанию (без аргументов) git log перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке – последние коммиты находятся вверху. 
Отображает список последних коммитов в порядке выполнения.
В нем содержится вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны.
Показывает все коммиты от новых к старым. Для каждого коммита выводится

* хэш
* автор
+ дата 
+ сообщение (commit message)


Команда **git log --oneline**

    git log --oneline

Команда покажет все ваши коммиты только с первой частью хэша и сообщением фиксации (commit message). Каждая фиксация будет находиться в одной строке, как oneline - одна линия.
Опция oneline печатает каждую фиксацию в одной строке, что полезно, если вы смотрите на множество коммитов.


Команда **git log --all**

    git log --all

Перечисляет все коммиты, сделанные в репозитории.


Команда **git log --all --oneline**

    git log --all --oneline

Команда покажет все ваши коммиты только с первой частью хэша


Команда **git log --stat --graph**
    
    git log --stat --graph

Выводит коммиты в виде дерева, в командной строке псевдографикой. Плюс выводит список измененных файлов, печатает под каждым из коммитов список и количество измененных файлов, отображает ASCII граф с ветвлениями и историей слияний.


Команда **git log --graph**
    
    git log --graph

Выводит коммиты в виде дерева


Команда **git diff**

    git diff

_Просмотр изменений до коммита_

Можно просматривать список изменений, внесённых в репозиторий


Команда **git checkout**

    git checkout
    
Если предположить, что ваш рабочий репозиторий уже содержит существующие ветки, вы можете переключаться между этими ветками с помощью команды git checkout. 


Команда **git checkout ＜new-branch＞**

    git checkout ＜new-branch＞

Команда git checkout ＜new-branch＞ выполняет переключение на новую ветку new_branch.


Команда **git checkout -b ＜new-branch＞**

    git checkout -b ＜new-branch＞

Команда git checkout также принимает аргумент -b, который действует как вспомогательный метод, позволяя создать новую ветку и сразу переключиться на нее, набрав команду git checkout -b ＜new-branch＞


Команда **git branch**

    git branch

Чтобы узнать, какие ветки доступны и как называется текущая ветка, выполните команду git branch.


Команда **git branch new_branch**

    git branch new_branch

 С помощью команды git branch можно создать новую ветку. Когда вы захотите начать работу над новой функцией, создайте новое ответвление от ветки main/master с помощью команды git branch new_branch. Затем переключитесь на новую ветку с помощью команды git checkout new_branch


Команда **git branch -d**

    git branch -d new_branch

Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде
Тогда используем данную команду, где флажок -d являющийся опцией команды git branch - это сокращенная версия ключевого слова --delete, предназначенного для удаления ветки, а new_branch – название ненужной нам ветки.
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку.
Так что при удалении ветвей, обязательно переключитесь на другой branch.


Команда **git merge**

    git merge <...>
    
    git merge <сливаемая ветка>

Команда git merge выполняет слияние отдельных направлений разработки, созданных с помощью команды git branch, в единую ветку.
Слияние веток – это перенос изменений с одной ветки на другую. При этом слияние не затрагивает сливаемую ветку, то есть она остается в том же состоянии, что позволяет нам потом продолжить работу с ней.
Сливаемая ветка – та ветка, с которой мы берем изменения, чтобы влить их в целевую.
Целевая ветка – та ветка, в которую мы сливаем наши изменения.
Перед слиянеим веток нужно перейти в целевую ветку через команду git checkout new_branch.


## Удаленные репозитории

Удаленный (иногда говорят "внешний") репозиторий – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.
Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – origin/main. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории .git/refs/remotes/<имя_удаленного_репозитория>.


Команда **git push**

    git push

Команда git push используется для выгрузки содержимого локального репозитория в удаленный репозиторий. Она позволяет передать коммиты из локального репозитория в удаленный. Эта команда симметрична команде git fetch: при извлечении с помощью fetch коммиты импортируются в локальные ветки, а при публикации с помощью push коммиты экспортируются в удаленные ветки. Настроить удаленные ветки можно с помощью команды git remote. Команда push может перезаписать изменения, поэтому при ее использовании следует соблюдать осторожность. 


Команда **git pull**

    git pull

Команда git pull используется для извлечения и загрузки содержимого из удаленного репозитория и немедленного обновления локального репозитория этим содержимым. Слияние удаленных вышестоящих изменений в локальный репозиторий — это обычная задача рабочего процесса, возникающая при совместной работе на основе системы Git. Команда git pull на самом деле представляет собой комбинацию двух других команд: git fetch и git merge. На первом этапе git pull выполняется команда git fetch, ограниченная локальной веткой, на которую указывает HEAD. Сразу после загрузки содержимого команда git pull выполняет слияние. Для слитого содержимого создается новый коммит, а указатель HEAD обновляется и начинает указывать на этот новый коммит.

Итого:

+ Команда git pull используется для синхронизации локальной рабочей копии и всех ссылочных объектов с удаленным репозиторием.
+ По сути, git pull - это то же самое, что git fetch + git merge.


Команда **git clone**

    git clone
    git clone <адрес_репозитория>

Как же теперь другой человек получит все наши изменения?
Для этого нам понадобиться GitHub или любой другой сервис для хранения кода. Что нужно чтобы скопировать код/часть информации обратно себе на компьютер?

Допустим, если у вашего друга раньше не было проекта, то ему придется его "клонировать" себе, используя команду
git clone <адрес_репозитория>.
Адрес репозитория на GitHub можно получить, нажав на зеленую кнопку Code.
После выполнения команды, в папке появиться проект и ваш друг сможет с ним работать. Все ветки и их история также подтянуться.
Т.е. операция клонирования создаёт на вашем компьютере точную копию удаленного репозитория.

Давайте на примере разберем, как происходит клонирование. Допустим мы клонируем некий репозиторий geometric_lib. При выполнении команды git сlone https://github.com/smartiqaorg/geometric_lib.git произойдет следующее:

В директории, откуда мы запустили команду git clone, создается директория с именем репозитория. В нашем случае, если мы выполнили команду из директории пользователя, будет создана папка C:\users\smartiqa\geometric_lib\.
В созданную директорию копируется репозиторий, все его ветки и коммиты.
В новосозданный локальный репозиторий добавляется удаленный репозиторий с именем origin и ссылкой, которую мы передавали в git clone. Это избавляет нас от необходимости вручную писать git remote add origin https://github.com/smartiqaorg/geometric_lib.git. На этом процесс клонирования заканчивается.

Завершил инструкцию
